//--------------------------------------------------
//--                                                                                                                    
//-- version 1.3 
//--                                                                                                                    
//--------------------------------------------------
//--------------------------------------------------
//  
//      Verilog code generated by Visual Elite
//
//  Design Unit:
//  ------------
//      Unit    Name  :  Top_Logic
//      Library Name  :  Top_Logic
//  
//      Creation Date :  Wed Jul 25 08:35:45 2012
//      Version       :  2011.02 v4.3.0 build 24. Date: Mar 21 2011. License: 2011.3
//  
//  Options Used:
//  -------------
//      Target
//         Language   :  Verilog
//         Purpose    :  Synthesis
//         Vendor     :  Leonardo
//  
//      Style
//         Use tasks                      :  No
//         Code Destination               :  Combined file
//         Attach Directives              :  Yes
//         Structural                     :  No
//         IF for state selection         :  No
//         Error (default) state          :  Yes
//         String typed state variable    :  No
//         Next state assignments         :  Non blocking
//         Free text style                :  / / ...
//         Preserve spacing for free text :  Yes
//         Declaration alignment          :  No
//         Sort Ports by mode             :  No
//         New line for each Port         :  No
//         Attach comment to Port         :  No
//
//--------------------------------------------------
//--------------------------------------------------
//  
//  Library Name :  Top_Logic
//  Unit    Name :  Top_Logic
//  Unit    Type :  State Machine
//  
//----------------------------------------------------
 
 
`timescale 1ns/1ps
module Top_Logic (clk, rst_b, empty_fifo_L1, empty_fifo_R3, L1_DCL_busy,
                  R3_DCL_busy, L1_rden, R3_rden, read_veto, delay_reg,
                  SEUFlag);
 
  input clk;
  wire clk;
  input rst_b;
  wire rst_b;
  input empty_fifo_L1;
  wire empty_fifo_L1;
  input empty_fifo_R3;
  wire empty_fifo_R3;
  input L1_DCL_busy;
  wire L1_DCL_busy;
  input R3_DCL_busy;
  wire R3_DCL_busy;
  output L1_rden;
  reg L1_rden;
  output R3_rden;
  reg R3_rden;
  input read_veto;
  wire read_veto;
  input [5:0] delay_reg;
  wire [5:0] delay_reg;
  reg [5:0] delay_count;
  output SEUFlag;
 
  parameter WAIT    = 4'b0000,
            DELAY   = 4'b0001,
            L1_PCSS = 4'b0010,
            R3_PCSS = 4'b0011,
            VETO1   = 4'b0101,
            VETO2   = 4'b0110,
            VETO3   = 4'b0111,
	    VETO4   = 4'b1000,
	    VETO5   = 4'b1001;
 
 
  reg [3:0] state_current;
  reg SEUFlag;
 
 
  // Synchronous process
  always  @(posedge clk)
  begin : Top_Logic_WAIT
 
    if (~(rst_b))
    begin
      L1_rden <= 1'b0;
      R3_rden <= 1'b0;
      delay_count<=delay_reg;
      state_current <= WAIT;
      SEUFlag <= 1'b0;
    end
    else
    begin
 
      case (state_current)  // exemplar parallel_case full_case
        WAIT:
          begin
	    SEUFlag <= 1'b0;
	    if (read_veto)
            begin
              state_current <= VETO5;
            end
            else if ((~(empty_fifo_R3) && ~(R3_DCL_busy)) || (~(empty_fifo_L1) && ~(
                L1_DCL_busy)))
            begin
              state_current <= DELAY;
            end
            else
            begin
              delay_count<=delay_reg;
              state_current <= WAIT;
            end
          end
 
        DELAY:
          begin
	    if (read_veto)
            begin
              state_current <= VETO1;
            end
            else if (delay_count != 6'b000000)
            begin
              delay_count <= delay_count - 1;
              state_current <= DELAY;
            end
            else if (delay_count == 6'b000000 && ~(empty_fifo_R3) && ~(
                     R3_DCL_busy))
            begin
              R3_rden <= 1'b1;
              state_current <= R3_PCSS;
            end
            else if (delay_count == 6'b000000 && ~(empty_fifo_L1) && ~(
                     L1_DCL_busy))
            begin
              L1_rden <= 1'b1;
              state_current <= L1_PCSS;
            end
            else
              state_current <= DELAY;
          end
 
        L1_PCSS:
          begin
            if (~(L1_DCL_busy))
            begin
              L1_rden <= 1'b0;
              state_current <= L1_PCSS;
            end
            else if (L1_DCL_busy)
            begin
              L1_rden <= 1'b0;
              delay_count<=delay_reg;
              state_current <= WAIT;
            end
            else
              state_current <= L1_PCSS;
          end
 
        R3_PCSS:
          begin
            if (~(R3_DCL_busy))
            begin
              R3_rden <= 1'b0;
              state_current <= R3_PCSS;
            end
            else if (R3_DCL_busy)
            begin
              R3_rden <= 1'b0;
              delay_count<=delay_reg;
              state_current <= WAIT;
            end
            else
              state_current <= R3_PCSS;
          end
 
        VETO1:
          begin
            state_current <= VETO2;
          end
 
        VETO2:
          begin
            state_current <= VETO3;
          end
 
        VETO3:
          begin
            state_current <= DELAY;
          end
	  
	VETO4:
          begin
            state_current <= DELAY;
          end
	  
	VETO5:
          begin
            state_current <= WAIT;
          end
 
        default:
          begin
            state_current <= WAIT;
	    SEUFlag <= 1'b1;
          end
      endcase
    end
  end
 
 
 
endmodule

