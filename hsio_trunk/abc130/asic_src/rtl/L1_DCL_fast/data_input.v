//--------------------------------------------------
//--                                                                                                                                                                                                  
//--version 1.4 
//--                                                                                                                                                                                                  
//--------------------------------------------------
//--------------------------------------------------
//  
//      Verilog code generated by Visual Elite
//
//  Design Unit:
//  ------------
//      Unit    Name  :  data_input
//      Library Name  :  L1_DCL_fast
//  
//      Creation Date :  Thu Dec 13 09:42:34 2012
//      Version       :  2011.02 v4.3.0 build 24. Date: Mar 21 2011. License: 2011.3
//  
//  Options Used:
//  -------------
//      Target
//         Language   :  Verilog
//         Purpose    :  Synthesis
//         Vendor     :  Leonardo
//  
//      Style
//         Use tasks                      :  No
//         Code Destination               :  Combined file
//         Attach Directives              :  Yes
//         Structural                     :  No
//         Free text style                :  / / ...
//         Preserve spacing for free text :  Yes
//         Declaration alignment          :  No
//
//--------------------------------------------------
//--------------------------------------------------
//  
//  Library Name :  L1_DCL_fast
//  Unit    Name :  data_input
//  Unit    Type :  Text Unit
//  
//----------------------------------------------------
//////////////////////////////////////////
//////////////////////////////////////////
// Date        : Thu May 25 11:55:05 2012
//
// Author      : Daniel La Marra / Pernecker Sébastien
//
// Company     : Physics school - DPNC
//
// Description : Three time slot 64 bits registers loaded from the pipeline
//
//////////////////////////////////////////
//////////////////////////////////////////


`timescale  1ns/1ps

module data_input(clk, rst_b, wr_disable, mode, in_mema, in_memc, in_memd, buff_wra, buff_wrc, buff_wrd, scan, force_scan, hit_found, scan_finished, ch, hit0, hit1, hit2, hit3);

   output               hit_found, scan_finished;
   output [5:0]         ch;
   output [2:0]         hit0,hit1,hit2,hit3;
 			 
   input [63:0]        in_mema, in_memc, in_memd;
   input [1:0]          mode;
   input                buff_wra, buff_wrc, buff_wrd;
   input                wr_disable;
   input                force_scan;
   input                scan;
   input                rst_b;
   input                clk;
   
   // Register in the design
   reg [63:0] 	 pattern_new;
   reg [63:0] 	 pattern_middle;
   reg [63:0] 	 pattern_old;
   reg [5:0]     ch;
   reg           found, scan_finished, mode11_mask;

   //Wire
   wire [2:0]    hit0,hit1,hit2,hit3;
   wire          stop_scan, force_scan, scan, hit_found;
   wire          buff_wra, buff_wrc, buff_wrd;

   assign        hit0[0] = pattern_new[0];
   assign        hit0[1] = pattern_middle[0];
   assign        hit0[2] = pattern_old[0];

   assign        hit1[0] = pattern_new[1];
   assign        hit1[1] = pattern_middle[1];
   assign        hit1[2] = pattern_old[1];

   assign        hit2[0] = pattern_new[2];
   assign        hit2[1] = pattern_middle[2];
   assign        hit2[2] = pattern_old[2];

   assign        hit3[0] = pattern_new[3];
   assign        hit3[1] = pattern_middle[3];
   assign        hit3[2] = pattern_old[3];

   assign stop_scan = (~mode[1] && ~mode[0] && ( pattern_new[0] || pattern_middle[0] || pattern_old[0] ) ||
                      ~mode[1] &&  mode[0] && pattern_middle[0] ||
                       mode[1] && ~mode[0] && ~pattern_old[0] && pattern_middle[0] ||
                       mode[1] &&  mode[0] && ~mode11_mask) &&
                       ~force_scan;

   assign hit_found = found && stop_scan;
   
   always @(posedge clk) begin
      if(~rst_b) begin
         pattern_new[63:0] <= {64{1'b0}};
         pattern_middle[63:0] <= {64{1'b0}};
         pattern_old[63:0] <= {64{1'b0}};
         found <= 1'b0;
         ch <= 6'b0;
         scan_finished <= 1'b0;
         mode11_mask <= 1'b0;
      end
      else begin
	 if(buff_wra && ~wr_disable) begin
	    pattern_new[63:0] <= in_mema[63:0];
         end
         if(buff_wrc && ~wr_disable) begin
	    pattern_middle[63:0] <= in_memc[63:0];
         end
         if(buff_wrd && ~wr_disable) begin
	    pattern_old[63:0] <= in_memd[63:0];
            ch <= 6'b0;
            mode11_mask <= 1'b0;
            scan_finished <= 1'b0;
	 end
         case (mode)
           2'b00: begin
	      // Detector allignement
              found <= pattern_new[0] | pattern_middle[0] | pattern_old[0];
           end
           2'b01: begin
	      // Normal Data Taking: Level
              found <= pattern_middle[0];
           end
           2'b10: begin
	      // Normal Data Taking: Edge
              found <= ~pattern_old[0] & pattern_middle[0];
           end
           2'b11: begin
	      // Test mode
              found <= 1'b1;
           end
         endcase // case(mode)
         if (scan && ~stop_scan) begin
            pattern_new[63:0] <= {1'b0,pattern_new[63:1]};
            pattern_middle[63:0] <= {1'b0,pattern_middle[63:1]};
            pattern_old[63:0] <= {1'b0,pattern_old[63:1]};
            if (ch==6'b111111) begin
               scan_finished <= 1'b1;
               mode11_mask <= 1'b1;
            end
            else begin
               ch <= ch + 1;
               mode11_mask <= 1'b0;
            end
         end // if (scan && ~stop_scan)
      end
   end 
endmodule



