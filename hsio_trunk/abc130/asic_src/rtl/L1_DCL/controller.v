//--------------------------------------------------
//--                                                                              
//-- version 1.8 
//--                                                                              
//--------------------------------------------------
//--------------------------------------------------
//  
//      Verilog code generated by Visual Elite
//
//  Design Unit:
//  ------------
//      Unit    Name  :  controller
//      Library Name  :  L1_DCL
//  
//      Creation Date :  Thu Apr 19 10:22:22 2012
//      Version       :  2011.02 v4.3.0 build 24. Date: Mar 21 2011. License: 2011.3
//  
//  Options Used:
//  -------------
//      Target
//         Language   :  Verilog
//         Purpose    :  Synthesis
//         Vendor     :  Leonardo
//  
//      Style
//         Use tasks                      :  No
//         Code Destination               :  Combined file
//         Attach Directives              :  Yes
//         Structural                     :  No
//         IF for state selection         :  No
//         Error (default) state          :  Yes
//         String typed state variable    :  No
//         Next state assignments         :  Non blocking
//         Free text style                :  / / ...
//         Preserve spacing for free text :  Yes
//         Declaration alignment          :  No
//         Sort Ports by mode             :  No
//         New line for each Port         :  No
//         Attach comment to Port         :  No
//
//--------------------------------------------------
//--------------------------------------------------
//  
//  Library Name :  L1_DCL
//  Unit    Name :  controller
//  Unit    Type :  State Machine
//  
//----------------------------------------------------
 
 
`timescale 1ns/100ps
module controller (clk, rst_b, busy, buffwr, odd_scan, even_scan,
                   odd_hit_found, even_hit_found, odd_selected, even_selected,
                   next_hit, datavalid, even_scan_finished, odd_scan_finished,
                   even_force_scan, odd_force_scan, finished, wtdg_rstrt
                   );
 
  input clk;
  wire clk;
  input rst_b;
  wire rst_b;
  output busy;
  reg busy;
  input buffwr;
  wire buffwr;
  output odd_scan;
  reg odd_scan;
  output even_scan;
  reg even_scan;
  input odd_hit_found;
  wire odd_hit_found;
  input even_hit_found;
  wire even_hit_found;
  output odd_selected;
  reg odd_selected;
  output even_selected;
  reg even_selected;
  input next_hit;
  wire next_hit;
  output datavalid;
  reg datavalid;
  input even_scan_finished;
  wire even_scan_finished;
  input odd_scan_finished;
  wire odd_scan_finished;
  output even_force_scan;
  reg even_force_scan;
  output odd_force_scan;
  reg odd_force_scan;
  output finished;
  wire finished;
  output wtdg_rstrt;
  reg wtdg_rstrt;
  reg scan;
  reg odd_dcl_done;
  reg even_dcl_done;
  reg odd_next;
  reg even_next;
  reg [2:0] escan_count;
  reg [2:0] oscan_count;
 
  parameter RST   = 2'b00,
            BFFWR = 2'b01,
            EVEN  = 2'b10,
            ODD   = 2'b11;
 
 
  reg [1:0] visual_RST_current;
 
 
  parameter ESC_WAIT  = 3'b000,
            ECHECK    = 3'b001,
            ESC_SCAN  = 3'b010,
            ESC_SCAN4 = 3'b011,
            ESC_STP   = 3'b100;
 
 
  reg [2:0] visual_ESC_WAIT_current;
 
 
  parameter OSC_WAIT  = 3'b000,
            OCHECK    = 3'b001,
            OSC_SCAN  = 3'b010,
            OSC_SCAN4 = 3'b011,
            OSC_STP   = 3'b100;
 
 
  reg [2:0] visual_OSC_WAIT_current;
 
 
 
  // Synchronous process
  always  @(posedge clk or negedge rst_b)
  begin : controller_RST
 
    if (~(rst_b))
    begin
      busy <= 1'b0;
      scan <= 1'b0;
      odd_next <= 1'b0;
      even_next <= 1'b0;
      odd_selected <= 1'b0;
      even_selected <= 1'b0;
      datavalid <= 1'b0;
      wtdg_rstrt <= 1'b1;
      visual_RST_current <= RST;
    end
    else
    begin
 
      case (visual_RST_current)  // exemplar parallel_case full_case
        RST:
          begin
            if (buffwr)
            begin
              wtdg_rstrt <= 1'b0;
              busy<=1'b1;
              visual_RST_current <= BFFWR;
            end
            else
            begin
              visual_RST_current <= RST;
            end
          end
 
        BFFWR:
          begin
            if (even_dcl_done && ~(even_next))
            begin
              even_selected <= 1'b1;
              odd_selected <= 1'b0;
              datavalid <= 1'b1;
              visual_RST_current <= EVEN;
            end
            else if (~(even_dcl_done) && odd_dcl_done && ~(odd_next))
            begin
              even_selected <= 1'b0;
              odd_selected <= 1'b1;
              datavalid <= 1'b1;
              visual_RST_current <= ODD;
            end
            else if (even_scan_finished && odd_scan_finished && ~(even_dcl_done)
                     && ~(odd_dcl_done) && next_hit)
            begin
              busy<=1'b0;
              scan <= 1'b0;
              odd_next <= 1'b0;
              even_next <= 1'b0;
              odd_selected <= 1'b0;
              even_selected <= 1'b0;
              datavalid <= 1'b0;
              wtdg_rstrt <= 1'b1;
              visual_RST_current <= RST;
            end
            else
            begin
              scan <= 1'b1;
              even_next <= 1'b0;
              odd_next <= 1'b0;
              visual_RST_current <= BFFWR;
            end
          end
 
        EVEN:
          begin
            if (next_hit && ~(odd_dcl_done))
            begin
              even_next <= 1'b1;
              even_selected <= 1'b0;
              datavalid <= 1'b0;
              busy<=1'b1;
              visual_RST_current <= BFFWR;
            end
            else if (next_hit && odd_dcl_done)
            begin
              even_next <= 1'b1;
              even_selected <= 1'b0;
              odd_selected <= 1'b1;
              datavalid <= 1'b1;
              visual_RST_current <= ODD;
            end
            else
            begin
              odd_next <= 1'b0;
              visual_RST_current <= EVEN;
            end
          end
 
        ODD:
          begin
            if (next_hit && even_dcl_done)
            begin
              odd_next <= 1'b1;
              even_selected <= 1'b1;
              odd_selected <= 1'b0;
              datavalid <= 1'b1;
              visual_RST_current <= EVEN;
            end
            else if (next_hit && ~(even_dcl_done))
            begin
              odd_next <= 1'b1;
              odd_selected <= 1'b0;
              datavalid <= 1'b0;
              busy<=1'b1;
              visual_RST_current <= BFFWR;
            end
            else
            begin
              even_next <= 1'b0;
              visual_RST_current <= ODD;
            end
          end
 
        default:
          begin
            visual_RST_current <= RST;
          end
      endcase
    end
  end
 
 
 
  // Synchronous process
  always  @(posedge clk or negedge rst_b)
  begin : controller_ESC_WAIT
 
    if (~(rst_b))
    begin
      even_scan <= 1'b0;
      even_dcl_done <= 1'b0;
      escan_count <= 3'b000;
      even_force_scan <= 1'b0;
      visual_ESC_WAIT_current <= ESC_WAIT;
    end
    else
    begin
 
      case (visual_ESC_WAIT_current)  // exemplar parallel_case full_case
        ESC_WAIT:
          begin
            if (scan == 1)
            begin
              visual_ESC_WAIT_current <= ECHECK;
            end
            else
            begin
              visual_ESC_WAIT_current <= ESC_WAIT;
            end
          end
 
        ECHECK:
          begin
            if (even_hit_found == 1)
            begin
              even_dcl_done <= 1'b1;
              even_scan <= 1'b0;
              escan_count <= 3'b100;
              visual_ESC_WAIT_current <= ESC_STP;
            end
            else if (even_hit_found == 0)
            begin
              even_scan <= 1'b1;
              even_force_scan <= 1'b0;
              visual_ESC_WAIT_current <= ESC_SCAN;
            end
            else
              visual_ESC_WAIT_current <= ECHECK;
          end
 
        ESC_SCAN:
          begin
            if (even_hit_found == 1 && scan == 1)
            begin
              even_dcl_done <= 1'b1;
              even_scan <= 1'b0;
              escan_count <= 3'b100;
              visual_ESC_WAIT_current <= ESC_STP;
            end
            else if (scan == 0)
            begin
              even_scan <= 1'b0;
              even_dcl_done <= 1'b0;
              escan_count <= 3'b000;
              even_force_scan <= 1'b0;
              visual_ESC_WAIT_current <= ESC_WAIT;
            end
            else
            begin
              visual_ESC_WAIT_current <= ESC_SCAN;
            end
          end
 
        ESC_SCAN4:
          begin
            if (escan_count != 3'b000)
            begin
              escan_count <= escan_count - 1;
              visual_ESC_WAIT_current <= ESC_SCAN4;
            end
            else if (escan_count == 3'b000)
            begin
              even_scan <= 1'b1;
              even_force_scan <= 1'b0;
              visual_ESC_WAIT_current <= ESC_SCAN;
            end
            else
              visual_ESC_WAIT_current <= ESC_SCAN4;
          end
 
        ESC_STP:
          begin
            if (even_next == 1)
            begin
              escan_count <= escan_count - 1;
              even_scan <= 1'b1;
              even_dcl_done <= 1'b0;
              even_force_scan <= 1'b1;
              visual_ESC_WAIT_current <= ESC_SCAN4;
            end
            else if (even_next == 0)
            begin
              visual_ESC_WAIT_current <= ESC_STP;
            end
            else
              visual_ESC_WAIT_current <= ESC_STP;
          end
 
        default:
          begin
            even_scan <= 1'b0;
            even_dcl_done <= 1'b0;
            escan_count <= 3'b000;
            even_force_scan <= 1'b0;
            visual_ESC_WAIT_current <= ESC_WAIT;
          end
      endcase
    end
  end
 
 
 
  // Synchronous process
  always  @(posedge clk or negedge rst_b)
  begin : controller_OSC_WAIT
 
    if (~(rst_b))
    begin
      odd_scan <= 1'b0;
      odd_dcl_done <= 1'b0;
      oscan_count <= 3'b000;
      odd_force_scan <= 1'b0;
      visual_OSC_WAIT_current <= OSC_WAIT;
    end
    else
    begin
 
      case (visual_OSC_WAIT_current)  // exemplar parallel_case full_case
        OSC_WAIT:
          begin
            if (scan == 1)
            begin
              visual_OSC_WAIT_current <= OCHECK;
            end
            else
            begin
              visual_OSC_WAIT_current <= OSC_WAIT;
            end
          end
 
        OCHECK:
          begin
            if (odd_hit_found == 1)
            begin
              odd_dcl_done <= 1'b1;
              odd_scan <= 1'b0;
              oscan_count <= 3'b100;
              visual_OSC_WAIT_current <= OSC_STP;
            end
            else if (odd_hit_found == 0)
            begin
              odd_scan <= 1'b1;
              odd_force_scan <= 1'b0;
              visual_OSC_WAIT_current <= OSC_SCAN;
            end
            else
              visual_OSC_WAIT_current <= OCHECK;
          end
 
        OSC_SCAN:
          begin
            if (odd_hit_found == 1 && scan == 1)
            begin
              odd_dcl_done <= 1'b1;
              odd_scan <= 1'b0;
              oscan_count <= 3'b100;
              visual_OSC_WAIT_current <= OSC_STP;
            end
            else if (scan == 0)
            begin
              odd_scan <= 1'b0;
              odd_dcl_done <= 1'b0;
              oscan_count <= 3'b000;
              odd_force_scan <= 1'b0;
              visual_OSC_WAIT_current <= OSC_WAIT;
            end
            else
            begin
              visual_OSC_WAIT_current <= OSC_SCAN;
            end
          end
 
        OSC_SCAN4:
          begin
            if (oscan_count != 3'b000)
            begin
              oscan_count <= oscan_count - 1;
              visual_OSC_WAIT_current <= OSC_SCAN4;
            end
            else if (oscan_count == 3'b000)
            begin
              odd_scan <= 1'b1;
              odd_force_scan <= 1'b0;
              visual_OSC_WAIT_current <= OSC_SCAN;
            end
            else
              visual_OSC_WAIT_current <= OSC_SCAN4;
          end
 
        OSC_STP:
          begin
            if (odd_next == 1)
            begin
              oscan_count <= oscan_count - 1;
              odd_scan <= 1'b1;
              odd_dcl_done <= 1'b0;
              odd_force_scan <= 1'b1;
              visual_OSC_WAIT_current <= OSC_SCAN4;
            end
            else if (odd_next == 0)
            begin
              visual_OSC_WAIT_current <= OSC_STP;
            end
            else
              visual_OSC_WAIT_current <= OSC_STP;
          end
 
        default:
          begin
            odd_scan <= 1'b0;
            odd_dcl_done <= 1'b0;
            oscan_count <= 3'b000;
            odd_force_scan <= 1'b0;
            visual_OSC_WAIT_current <= OSC_WAIT;
          end
      endcase
    end
  end
 
  assign finished = even_scan_finished && odd_scan_finished;
 
 
endmodule

