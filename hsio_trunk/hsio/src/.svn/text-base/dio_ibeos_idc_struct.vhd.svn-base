-- VHDL Entity hsio.dio_ibeos_idc.symbol
--
-- Created by Matt Warren 2014
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2013.1 (Build 6)
--

library ieee;
use ieee.std_logic_1164.all;
use ieee.std_logic_arith.all;
use ieee.std_logic_unsigned.all;
library utils;
use utils.pkg_types.all;
library hsio;
use hsio.pkg_core_globals.all;

entity dio_ibeos_idc is
   generic( 
      LINK_ID_MIN : integer := 0
   );
   port( 
      clk                : in     std_logic;
      com_i              : in     std_logic;
      dat0_ni            : in     std_logic;                      -- ID0_0B (J32.14/J33.10) ID0_0B_BUF (J26.H3)
      dat0_pi            : in     std_logic;                      -- ID0_0 (J32.13/J33.9) ID0_0_BUF (J26.G3)
      dat1_ni            : in     std_logic;                      -- ID0_0B (J32.14/J33.10) ID0_0B_BUF (J26.H3)
      dat1_pi            : in     std_logic;                      -- ID0_0 (J32.13/J33.9) ID0_0_BUF (J26.G3)
      --idelay_ce_o   : out    std_logic_vector (71 downto 0);
      --idelay_inc_o  : out    std_logic;
      --idelay_zero_o : out    std_logic_vector (71 downto 0);
      idelay_ctl_i       : in     t_idelay_ctl;
      l1r_i              : in     std_logic;
      rawcom_en_com_i    : in     std_logic;
      rawcom_en_l1r_i    : in     std_logic;
      rawcom_en_rst_i    : in     std_logic;
      rawcom_i           : in     std_logic;
      -- registers
      reg                : in     t_reg_bus;
      reset_i            : in     std_logic;
      rst                : in     std_logic;
      strobe40_i         : in     std_logic;
      bco_no             : out    std_logic;                      -- CLKB (J33.4) CLKLB (J26.D4)
      bco_po             : out    std_logic;                      -- CLK (J33.3) CLKL (J26.C4)
      com_no             : out    std_logic;                      -- CLKB (J33.4) CLKLB (J26.D4)
      com_po             : out    std_logic;                      -- CLK (J33.3) CLKL (J26.C4)
      dbg_com_o          : out    std_logic;
      dbg_l1r_o          : out    std_logic;
      dbg_reset_o        : out    std_logic;
      dclk_no            : out    std_logic;                      -- CLKB (J33.4) CLKLB (J26.D4)
      dclk_po            : out    std_logic;                      -- CLK (J33.3) CLKL (J26.C4)
      l1r_no             : out    std_logic;                      -- CLKB (J33.4) CLKLB (J26.D4)
      l1r_po             : out    std_logic;                      -- CLK (J33.3) CLKL (J26.C4)
      reset_no           : out    std_logic;                      -- CLKB (J33.4) CLKLB (J26.D4)
      reset_po           : out    std_logic;                      -- CLK (J33.3) CLKL (J26.C4)
      rx_link_idelayed_o : out    std_logic_vector (1 downto 0);
      rx_strm_o          : out    std_logic_vector (3 downto 0)
   );

-- Declarations

end dio_ibeos_idc ;

-- VHDL from Block Diagram 
-- Generated by Mentor Graphics HDL Designer(TM) 2013.1 (Build 6) 
--
-- hsio.dio_ibeos_idc.struct
--
-- Created by Matt Warren 2014
--

library ieee;
use ieee.std_logic_1164.all;
use ieee.std_logic_arith.all;
use ieee.std_logic_unsigned.all;
library utils;
use utils.pkg_types.all;
library hsio;
use hsio.pkg_core_globals.all;

library unisim;
use unisim.VCOMPONENTS.all;


architecture struct of dio_ibeos_idc is

   -- Architecture declarations

   -- Internal signal declarations
   signal HI          : std_logic;
   signal LO          : std_logic;
   signal bco         : std_logic;
   signal bco_ddr     : std_logic;
   signal bco_ddr_n   : std_logic;
   signal bco_en      : std_logic;
   signal com         : std_logic;
   signal com_in      : std_logic;
   signal dclk        : std_logic;
   signal dclk_ddr_d1 : std_logic;
   signal dclk_ddr_d2 : std_logic;
   signal dclk_en     : std_logic;
   signal dclk_inv    : std_logic;
   signal dclk_mode40 : std_logic;
   signal l1r         : std_logic;
   signal l1r_in      : std_logic;
   signal rawcom_in   : std_logic;
   signal rawout_en_n : std_logic;
   signal reset       : std_logic;
   signal reset_in    : std_logic;
   signal rx_link     : std_logic_vector(1 downto 0);


attribute KEEP : string;
--attribute KEEP of reg_control_i : signal is "true";
--attribute KEEP of reg_com_enable_i : signal is "true";

   -- Component Declarations
   component four_phase
   port (
      sig_i      : in     std_logic ;
      sig_o      : out    std_logic ;
      --dbg_sig_o  : out    std_logic;
      dbg_sig0_o : out    std_logic ;
      --    sig_0_o   : out std_logic;
      --    sig_90_o  : out std_logic;
      --    sig_180_o : out std_logic;
      --    sig_270_o : out std_logic;
      sel_i      : in     std_logic_vector (1 downto 0);
      invert_i   : in     std_logic ;
      com_i      : in     std_logic ;
      com_en     : in     std_logic ;
      rst        : in     std_logic ;
      clk        : in     std_logic 
   );
   end component;
   component idelay_block
   generic (
      LINK_ID : integer := 0
   );
   port (
      clk                    : in     std_logic ;
      ddrdata_i              : in     std_logic ;
      --idelay_ce_o   : out    std_logic_vector (71 downto 0);
      --idelay_inc_o  : out    std_logic;
      --idelay_zero_o : out    std_logic_vector (71 downto 0);
      idelay_ctl_i           : in     t_idelay_ctl ;
      loopdata0_i            : in     std_logic ;
      loopdata1_i            : in     std_logic ;
      rst                    : in     std_logic ;
      dbg_ddrdata_idelayed_o : out    std_logic ;
      stream0_o              : out    std_logic ;
      stream1_o              : out    std_logic 
   );
   end component;
   component IBUFDS
   generic (
      CAPACITANCE      : string  := "DONT_CARE";
      DIFF_TERM        : boolean := FALSE;
      DQS_BIAS         : string  := "FALSE";
      IBUF_DELAY_VALUE : string  := "0";
      IBUF_LOW_PWR     : boolean := TRUE;
      IFD_DELAY_VALUE  : string  := "AUTO";
      IOSTANDARD       : string  := "DEFAULT"
   );
   port (
      I  : in     std_ulogic;
      IB : in     std_ulogic;
      O  : out    std_ulogic
   );
   end component;
   component OBUFDS
   generic (
      CAPACITANCE : string := "DONT_CARE";
      IOSTANDARD  : string := "DEFAULT";
      SLEW        : string := "SLOW"
   );
   port (
      I  : in     std_ulogic;
      O  : out    std_ulogic;
      OB : out    std_ulogic
   );
   end component;
   component ODDR
   generic (
      DDR_CLK_EDGE : string := "OPPOSITE_EDGE";
      INIT         : bit    := '0';
      SRTYPE       : string := "SYNC"
   );
   port (
      C  : in     std_ulogic;
      CE : in     std_ulogic;
      D1 : in     std_ulogic;
      D2 : in     std_ulogic;
      R  : in     std_ulogic;
      S  : in     std_ulogic;
      Q  : out    std_ulogic
   );
   end component;
   component m_power
   port (
      hi : out    std_logic ;
      lo : out    std_logic 
   );
   end component;


begin
   -- Architecture concurrent statements
   -- HDL Embedded Text Block 2 eb2
   -- eb2 2
   dclk_en <= reg(R_COM_ENA)(B_DCLK_EN);
   dclk_inv <= reg(R_COM_ENA)(B_DCLK_INV);
   --dclk_inv_n <= not(reg(R_COM_ENA)(B_DCLK_INV));
   
   dclk_mode40 <= reg(R_CONTROL)(CTL_DCLK40_MODE);
   
   dclk_ddr_d1 <= 
     not(dclk_inv) when (dclk_mode40 = '0') else
     (strobe40_i xor dclk_inv);
   
   dclk_ddr_d2 <= 
     dclk_inv when (dclk_mode40 = '0') else
     not (strobe40_i xor dclk_inv);

   -- HDL Embedded Text Block 3 eb3
   rawout_en_n <= not reg(R_CONTROL1)(CTL_RAWOUT_EN);

   -- HDL Embedded Text Block 4 eb4
   -- eb1 1
   bco_en <= reg(R_COM_ENA)(B_BCO_EN);
   -- for compat reasons bco is inverted
   bco_ddr <= 
     strobe40_i when (reg(R_COM_ENA)(B_BCO_INV) = '1') else
     not strobe40_i;
   


   -- ModuleWare code(v1.12) for instance 'U_0' of 'and'
   com_in <= rawout_en_n and com_i;

   -- ModuleWare code(v1.12) for instance 'U_1' of 'and'
   l1r_in <= rawout_en_n and l1r_i;

   -- ModuleWare code(v1.12) for instance 'U_2' of 'and'
   reset_in <= rawout_en_n and reset_i;

   -- ModuleWare code(v1.12) for instance 'U_4' of 'and'
   rawcom_in <= rawout_en_n and rawcom_i;

   -- ModuleWare code(v1.12) for instance 'U_3' of 'inv'
   bco_ddr_n <= not(bco_ddr);

   -- Instance port mappings.
   Ufourphase0 : four_phase
      port map (
         sig_i      => com_in,
         sig_o      => com,
         dbg_sig0_o => dbg_com_o,
         sel_i      => reg(R_COM_ENA)(15 DOWNTO 14),
         invert_i   => LO,
         com_i      => rawcom_in,
         com_en     => rawcom_en_com_i,
         rst        => rst,
         clk        => clk
      );
   Ufourphase1 : four_phase
      port map (
         sig_i      => l1r_in,
         sig_o      => l1r,
         dbg_sig0_o => dbg_l1r_o,
         sel_i      => reg(R_COM_ENA)(15 DOWNTO 14),
         invert_i   => LO,
         com_i      => rawcom_in,
         com_en     => rawcom_en_l1r_i,
         rst        => rst,
         clk        => clk
      );
   Ufourphase2 : four_phase
      port map (
         sig_i      => reset_in,
         sig_o      => reset,
         dbg_sig0_o => dbg_reset_o,
         sel_i      => reg(R_COM_ENA)(15 DOWNTO 14),
         invert_i   => reg(R_COM_ENA)(B_RST_INV),
         com_i      => rawcom_in,
         com_en     => rawcom_en_rst_i,
         rst        => rst,
         clk        => clk
      );
   Uibd2 : IBUFDS
      generic map (
         CAPACITANCE      => "DONT_CARE",
         DIFF_TERM        => TRUE,
         IBUF_DELAY_VALUE => "0",
         IFD_DELAY_VALUE  => "AUTO",
         IOSTANDARD       => "LVDS_25"
      )
      port map (
         O  => rx_link(0),
         I  => dat0_pi,
         IB => dat0_ni
      );
   Uibd3 : IBUFDS
      generic map (
         CAPACITANCE      => "DONT_CARE",
         DIFF_TERM        => TRUE,
         IBUF_DELAY_VALUE => "0",
         IFD_DELAY_VALUE  => "AUTO",
         IOSTANDARD       => "LVDS_25"
      )
      port map (
         O  => rx_link(1),
         I  => dat1_pi,
         IB => dat1_ni
      );
   Uob0 : OBUFDS
      generic map (
         CAPACITANCE => "DONT_CARE",
         IOSTANDARD  => "LVDS_25"
      )
      port map (
         O  => com_po,
         OB => com_no,
         I  => com
      );
   Uob1 : OBUFDS
      generic map (
         CAPACITANCE => "DONT_CARE",
         IOSTANDARD  => "LVDS_25"
      )
      port map (
         O  => bco_po,
         OB => bco_no,
         I  => bco
      );
   Uob2 : OBUFDS
      generic map (
         CAPACITANCE => "DONT_CARE",
         IOSTANDARD  => "LVDS_25"
      )
      port map (
         O  => l1r_po,
         OB => l1r_no,
         I  => l1r
      );
   Uob3 : OBUFDS
      generic map (
         CAPACITANCE => "DONT_CARE",
         IOSTANDARD  => "LVDS_25"
      )
      port map (
         O  => dclk_po,
         OB => dclk_no,
         I  => dclk
      );
   Uob4 : OBUFDS
      generic map (
         CAPACITANCE => "DONT_CARE",
         IOSTANDARD  => "LVDS_25"
      )
      port map (
         O  => reset_po,
         OB => reset_no,
         I  => reset
      );
   Uoddrbcopp0 : ODDR
      generic map (
         DDR_CLK_EDGE => "SAME_EDGE",
         INIT         => '0',
         SRTYPE       => "SYNC"
      )
      port map (
         Q  => bco,
         C  => clk,
         CE => bco_en,
         D1 => bco_ddr,
         D2 => bco_ddr_n,
         R  => rst,
         S  => LO
      );
   Uoddrdclkpp0 : ODDR
      generic map (
         DDR_CLK_EDGE => "SAME_EDGE",
         INIT         => '0',
         SRTYPE       => "SYNC"
      )
      port map (
         Q  => dclk,
         C  => clk,
         CE => dclk_en,
         D1 => dclk_ddr_d1,
         D2 => dclk_ddr_d2,
         R  => rst,
         S  => LO
      );
   Umpower : m_power
      port map (
         hi => HI,
         lo => LO
      );

   gdo1: FOR i IN 0 TO 1 GENERATE
      Uidelayblk : idelay_block
         generic map (
            LINK_ID => i+LINK_ID_MIN
         )
         port map (
            clk                    => clk,
            ddrdata_i              => rx_link(i),
            idelay_ctl_i           => idelay_ctl_i,
            loopdata0_i            => LO,
            loopdata1_i            => LO,
            rst                    => rst,
            dbg_ddrdata_idelayed_o => rx_link_idelayed_o(i),
            stream0_o              => rx_strm_o(i*2),
            stream1_o              => rx_strm_o(i*2+1)
         );
   end generate gdo1;

end struct;
